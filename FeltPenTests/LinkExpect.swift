//
//  LinkExpect.swift
//  FeltPen
//
//  Created by Aleksei Gordeev on 19/09/2017.
//  Copyright © 2017 Aleksei Gordeev. All rights reserved.
//

import Foundation

public class LinkExpect: CustomStringConvertible {
    let url: URL
    var urlVerified: Bool = false
    private var attemptUrl: URL? = nil
    
    public enum State: CustomStringConvertible {
        
        case notVerified
        case verified
        case failed
        
        public var description: String {
            switch self {
            case .failed: return "❌"
            case .notVerified: return "❓"
            case .verified: return "✅"
            }
        }
    }
    
    let range: NSRange
    var rangeVerified: Bool = false
    private var attemptRange: NSRange? = nil
    
    public var isVerified: Bool {
        return self.state == .verified
    }
    
    public func verify(url: URL, range: NSRange) {
        self.urlVerified = self.url == url
        self.attemptUrl = url
        
        self.rangeVerified = NSEqualRanges(self.range, range)
        self.attemptRange = range
    }
    
    public func verify(link: String, range: NSRange) {
        self.verify(url: URL.init(string: link)!, range: range)
    }
    
    var state: State {
        guard self.attemptUrl != nil, self.attemptRange != nil else {
            return .notVerified
        }
        
        return (self.urlVerified && self.rangeVerified) ? .verified : .failed
    }
    
    public var description: String {
        switch self.state {
        case .verified: return "[State verified. Url: \(url.absoluteString), range: \(NSStringFromRange(self.range))]"
        case .notVerified: return "[State not verified yet. Url: \(url.absoluteString), range: \(NSStringFromRange(self.range))]"
        case .failed:
            return "[State FAILED. URLS (\(self.verifiedDescription(self.urlVerified))): "
                + "\nexp: \(self.url)\nact: \(self.attemptUrl!)" +
                "\n"
                + "RANGES (\(self.verifiedDescription(self.rangeVerified))): "
                + "\nexp: \(NSStringFromRange(self.range))\nact: \(NSStringFromRange(self.attemptRange!))"
            
        }
    }
    
    private func verifiedDescription(_ value: Bool) -> String {
        guard self.state != .notVerified else {
            return State.notVerified.description
        }
        return value ? State.verified.description : State.failed.description
    }
    
    init(link: String, range: NSRange? = nil) {
        self.url = URL.init(string: link)!
        self.range = range ?? NSRange.init(fullRangeOfString: link)
    }
    
    convenience init(_ link: String, at range: Range<Int>) {
        let nsRange = NSRange(location: range.lowerBound, length: range.count)
        self.init(link: link, range: nsRange)
    }
    
    convenience init(link: String, findRangeIn: NSAttributedString) {
        let range = (findRangeIn.string as NSString).range(of: link)
        self.init(link: link, range: range)
    }
    
    init(url: URL, range: NSRange? = nil) {
        self.url = url
        self.range = range ?? NSRange.init(fullRangeOfString: url.absoluteString)
    }
}

public class ComplexLinkExpect {
    var text: NSMutableAttributedString
    let expects: [LinkExpect]
    
    public init(text: NSMutableAttributedString, expects: [LinkExpect]) {
        self.text = text
        self.expects = expects
    }
    
    public convenience init(_ string: String, _ expects: [LinkExpect]) {
        self.init(string: string, expects: expects)
    }
    
    public init(string: String, expects: [LinkExpect]) {
        self.text = NSMutableAttributedString.init(string: string)
        self.expects = expects
    }
    
    @discardableResult public func fullFilExpects() -> CompletLinkExpectResult {
        return self.text.fullfilExpects(expects)
    }
}

public extension NSAttributedString {
    func fullfilExpects(_ expects: [LinkExpect]) -> CompletLinkExpectResult {
        
        var failedExpects: [LinkExpect] = []
        var falsePositives: [CompletLinkExpectResult.FalsePositive] = []
        var idx = 0
        self.enumerateDetectorAttribute(.url, options: [], range: nil, block: { (value, range, _) in
            
            guard let v = value else {
                return
            }
            
            defer {
                idx += 1
            }
            
            let url = v as! URL
            guard idx < expects.count else {
                falsePositives.append(CompletLinkExpectResult.FalsePositive.init(id: self.string,
                                                                                 range: range,
                                                                                 url: url,
                                                                                 inText: self.string))
                return
            }
            
            let expect = expects[idx]
            expect.verify(url: url, range: range)
            if !expect.isVerified {
                failedExpects.append(expect)
            }
        })
        return CompletLinkExpectResult.init(failedExpects: failedExpects, falsePositives: falsePositives)
    }
}

public struct CompletLinkExpectResult: CustomStringConvertible {
    
    public var success: Bool {
        return failedExpects.count == 0 && falsePositives.count == 0
    }
    
    public var failedExpects: [LinkExpect]
    
    public var falsePositives: [FalsePositive]
    
    
    public struct FalsePositive: CustomStringConvertible {
        public let range: NSRange
        public let url: URL
        public let text: String
        
        public init(id: String, range: NSRange, url: URL, inText: String) {
            self.range = range
            self.url = url
            self.text = (inText as NSString).substring(with: range)
        }
        
        public var description: String {
            let items: [String] = [
                "Range: " + NSStringFromRange(self.range),
                "URL: " + url.absoluteString,
                "Text: " + self.text
            ]
            return items.joined(separator: ", ")
        }
    }
    
    public var description: String {
        if self.success {
            return "An success result"
        }
        
        var items: [String] = []
        if self.failedExpects.count > 0 {
            let failedDescrs = self.failedExpects.map(){$0.description}
            let string = failedDescrs.joined(separator: "\n")
            items.append("FAILED: \n" + string + "\n")
        }
        
        if self.falsePositives.count > 0 {
            let results = self.falsePositives.map(){$0.description}
            let string = results.joined(separator: "\n")
            items.append("FALSE POSITIVES: \n" + string + "\n")
        }
        return items.joined(separator: "\n")
    }
}
