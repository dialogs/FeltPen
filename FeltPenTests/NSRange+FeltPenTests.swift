//
//  NSRange+FeltPenTests.swift
//  FeltPen
//
//  Created by Aleksei Gordeev on 12/09/2017.
//  Copyright Â© 2017 Aleksei Gordeev. All rights reserved.
//

import XCTest
@testable import FeltPen


public func XCTAssertEqualRanges(expression1: @autoclosure () throws -> NSRange,
                                 expression2: @autoclosure () throws -> NSRange,
                                 file: StaticString = #file, line: UInt = #line) rethrows {
    let range1 = try expression1()
    let range2 = try expression2()
    XCTAssertTrue(NSEqualRanges(range1, range2),
                  "Range \(NSStringFromRange(range1)) isn't equal \(NSStringFromRange(range2))")
}

public func XCTAssertNotEqualRanges(expression1: @autoclosure () throws -> NSRange,
                                    expression2: @autoclosure () throws -> NSRange,
                                    file: StaticString = #file, line: UInt = #line) rethrows {
    let range1 = try expression1()
    let range2 = try expression2()
    XCTAssertFalse(NSEqualRanges(range1, range2),
                   "Range \(NSStringFromRange(range1)) is equal \(NSStringFromRange(range2))")
}

class NSRange_FeltPenTests: XCTestCase {
    
    private func createOneLengthRanges(count: Int) -> [NSRange] {
        guard count > 0 else {
            return []
        }
        
        var ranges: [NSRange] = []
        for i in 0..<count {
            ranges.append(NSRange(location: i, length: 1))
        }
        
        return ranges
    }
    
    func testFirstClosureRanges() {
        
        let string = "123 abc"
        
        /// Pattern with two closures
        let regex = try! NSRegularExpression(pattern: "([0-9]{3}).*([a-z]{3})", options: [])
        
        let expectedRange0 = NSRange.range(of: string)
        let expectedRange1 = (string as NSString).range(of: "123")
        let expectedRange2 = (string as NSString).range(of: "abc")
        XCTAssertNotEqualRanges(expression1: expectedRange1, expression2: expectedRange2)
        
        let results = regex.matches(in: string, options: [], range: NSRange.range(of: string))
        
        let ranges0 = results.rangesOfClosure(idx: 0)
        //        print("\(ranges0.map({NSStringFromRange($0.1)}))")
        XCTAssertEqual(ranges0.count, 1)
        XCTAssertEqualRanges(expression1: ranges0.first!.1, expression2: expectedRange0)
        XCTAssertTrue(NSEqualRanges(ranges0.first!.1, expectedRange0))
        
        let ranges1 = results.rangesOfClosure(idx: 1)
        //        print("\(ranges1.map({NSStringFromRange($0.1)}))")
        XCTAssertEqual(ranges1.count, 1)
        XCTAssertEqualRanges(expression1: ranges1.first!.1, expression2: expectedRange1)
        XCTAssertTrue(NSEqualRanges(ranges1.first!.1, expectedRange1))
        
        let ranges2 = results.rangesOfClosure(idx: 2)
        //        print("\(ranges2.map({NSStringFromRange($0.1)}))")
        XCTAssertEqual(ranges2.count, 1)
        XCTAssertEqualRanges(expression1: ranges2.first!.1, expression2: expectedRange2)
    }
    
    func testManyToOneSequenceUnionRanges() {
        let ranges = [NSRange(location: 0, length: 10),
                      NSRange(location: 10, length:10),
                      NSRange(location: 20, length: 5),
                      NSRange(location: 25, length: 3)]
        let unionRanges = ranges.unionRanges
        
        XCTAssertEqual(unionRanges.count, 1)
        XCTAssertTrue(NSEqualRanges(unionRanges.first!, NSRange(location: 0, length: 28)))
    }
    
    func testUnionRangesPerformance() {
        let ranges = createOneLengthRanges(count: 10000)
        measure({
            _ = ranges.unionRanges
        })
    }
    
    func testUnionRangesReturnsSelfForUniqueRanges() {
        let ranges = createOneLengthRanges(count: 1000)
        let unionRanges = ranges.unionRanges
        let reunionRanges = unionRanges.unionRanges
        
        XCTAssertEqual(unionRanges.count, reunionRanges.count)
        for entry in unionRanges.enumerated() {
            XCTAssertTrue(NSEqualRanges(entry.element, reunionRanges[entry.offset]))
        }
    }
    
    func testManyToManySequenceUnionRanges() {
        let ranges = [
            NSRange(location: 0, length: 5),
            NSRange(location: 5, length: 3),
            NSRange(location: 10, length: 8),
            NSRange(location: 18, length: 3)
        ]
        
        let unionRanges = ranges.unionRanges
        let expectedRanges = [
            NSRange(location: 0, length: 8),
            NSRange(location: 10, length: 11)
        ]
        XCTAssertEqual(unionRanges.count, expectedRanges.count)
        for entry in unionRanges.enumerated() {
            XCTAssertTrue(NSEqualRanges(entry.element, expectedRanges[entry.offset]))
        }
    }
    
    func testOverlapedUnionRanges() {
        let ranges = [
            NSRange(location: 0, length: 5),
            NSRange(location: 3, length: 7)
        ]
        
        let unionRanges = ranges.unionRanges
        let expectedUnionRange = NSRange(location: 0, length: 10)
        XCTAssertEqual(unionRanges.count, 1)
        XCTAssertTrue(NSEqualRanges(unionRanges.first!, expectedUnionRange))
    }
    
    func testEmptyUnionRanges() {
        let ranges: [NSRange] = []
        XCTAssertNoThrow(_ = ranges.unionRanges)
        
        let unionRanges = ranges.unionRanges
        XCTAssertTrue(unionRanges.isEmpty)
    }
    
    func testUnionZeroRanges() {
        let ranges = [
            NSRange(location: 0, length: 0),
            NSRange(location: 0, length: 0),
            NSRange(location: 1, length: 0),
            NSRange(location: 2, length: 0)
        ]
        
        let unionRanges = ranges.unionRanges
        
        let expectedRanges: [NSRange] = [
            NSRange(location: 0, length: 0),
            NSRange(location: 1, length: 0),
            NSRange(location: 2, length: 0)
        ]
        
        XCTAssertEqual(unionRanges.count, expectedRanges.count)
        for entry in unionRanges.enumerated() {
            XCTAssertTrue(NSEqualRanges(entry.element, expectedRanges[entry.offset]))
        }
    }
    
    func testSimpleRangeExtracting() {
        let range = NSRange(location: 0, length: 10)
        let exclusionRange = NSRange(location: 1, length: 1)
        
        let expectedRanges: [NSRange] = [
            NSRange(location: 0, length: 1),
            NSRange(location: 2, length: 8)
        ]
        
        let ranges = range.subranges(rangesToExtract: [exclusionRange])
        XCTAssertEqual(ranges.count, 2)
        
        ranges.enumerated().forEach({ idx, range in
            let expectedRange = expectedRanges[idx]
            XCTAssertEqualRanges(expression1: range, expression2: expectedRange)
        })
    }
    
}
