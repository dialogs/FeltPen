//
//  UrlDetectorTests.swift
//  FeltPen
//
//  Created by Aleksei Gordeev on 12/07/2017.
//  Copyright © 2017 Aleksei Gordeev. All rights reserved.
//

import XCTest
@testable import FeltPen


class UrlDetectorTests: XCTestCase {
    
    var detector: UrlDetector!
    
    private struct Checked {
        var full: Bool = false
        var text: Bool = false
        var link: Bool = false
    }
    
    private struct Expected {
        
        var fullRange: NSRange
        
        var text: String
        var textRange: NSRange
        var textChecked = false
        
        var link: String
        var linkRange: NSRange
        var linkChecked = false
        
        public init(string: String, fullRangeIn: String, text: String, link: String) {
            let nsstring = (string as NSString)
            self.fullRange = (fullRangeIn as NSString).range(of: string)
            
            self.text = text
            self.textRange = nsstring.range(of: text)
            
            self.link = link
            self.linkRange = nsstring.range(of: link)
        }
        
        public init(string: String, fullRange: NSRange? = nil, text: String, link: String) {
            let nsstring = (string as NSString)
            self.fullRange = fullRange ?? NSRange(location: 0, length: nsstring.length)
            
            self.text = text
            self.textRange = nsstring.range(of: text)
            
            self.link = link
            self.linkRange = nsstring.range(of: link)
        }
    }
    
    private func createText(_ string: String) -> NSMutableAttributedString {
        return NSMutableAttributedString.init(string: string)
    }
    
    private func enumerateAttribute(_ attr: DetectorAttributeName, in text: NSAttributedString, block: (Any?, NSRange)->()) {
        let range = NSRange.range(of: text.string)
        text.enumerateAttribute(attr.rawValue, in: range, options: [], using: { value, range, _ in
            block(value, range)
        })
    }
    
    override func tearDown() {
        self.detector = nil
        super.tearDown()
    }
    
    override func setUp() {
        super.setUp()
        self.detector = UrlDetector.init()
    }
    
    
    func testBasicUrl() {
        
        let expects = self.createExpects(link: "http://google.com")
        for entry in expects {
            let text = createText(entry.key)
            try! detector.process(text: text)
            
            let expected = entry.value
            
            var matchesCount = 0
            text.enumerateDetectorAttribute(.url, block: { value, range, _ in
                guard let v = value else {
                    return
                }
                guard let url = v as? URL else {
                    XCTFail("Unexpected detector result: \(String(describing: value))")
                    return
                }
                
                expected.verify(url: url, range: range)
                XCTAssertTrue(expected.isVerified, "Fail \(text.string):\n \(expected.description)")
                
                matchesCount += 1
            })
            XCTAssertEqual(matchesCount, 1, "Expected 1 match (got \(matchesCount)) in \(text.string)")
        }
    }
    
    func testBasicUrlWithEmptyPath() {
        let expects = self.createExpects(link: "http://google.com/")
        for entry in expects {
            let text = createText(entry.key)
            try! detector.process(text: text)
            
            let expected = entry.value
            
            var matchesCount = 0
            text.enumerateDetectorAttribute(.url, block: { value, range, _ in
                guard let v = value else {
                    return
                }
                guard let url = v as? URL else {
                    XCTFail("Unexpected detector result: \(String(describing: value))")
                    return
                }
                
                expected.verify(url: url, range: range)
                XCTAssertTrue(expected.isVerified, "Fail \(text.string):\n \(expected.description)")
                
                matchesCount += 1
            })
            
            XCTAssertEqual(matchesCount, 1, "Expected 1 match (got \(matchesCount)) in \(text.string)")
        }
    }
    
    func testBasicUrlWithSimplePath() {
        let expects = self.createExpects(link: "http://google.com/test")
        for entry in expects {
            let text = createText(entry.key)
            try! detector.process(text: text)
            
            let expected = entry.value
            
            var matchesCount = 0
            text.enumerateDetectorAttribute(.url, block: { value, range, _ in
                guard let v = value else {
                    return
                }
                guard let url = v as? URL else {
                    XCTFail("Unexpected detector result: \(String(describing: value))")
                    return
                }
                
                expected.verify(url: url, range: range)
                XCTAssertTrue(expected.isVerified, "Fail \(text.string):\n \(expected.description)")
                
                matchesCount += 1
            })
            
            XCTAssertEqual(matchesCount, 1, "Expected 1 match (got \(matchesCount)) in \(text.string)")
        }
    }
    
    func testBigComplexUrl() {
        
        var urlComponents = URLComponents()
        urlComponents.scheme = "https"
        urlComponents.host = "themerkle.com"
        urlComponents.path = "/kik-messsengers-kin-digital-currency-what-we-know-so-far/"
        urlComponents.query = "utm_medium=push&utm_source=onesignal&utm_campaign=traffic%20boost&utm_content=extended%20%traffic%boost"
        
        guard let url = urlComponents.url else {
            XCTFail("Could not create url from \(urlComponents)")
            return
        }
        
        let link = "https://themerkle.com/kik-messsengers-kin-digital-currency-what-we-know-so-far/?utm_medium=push&utm_source=onesignal&utm_campaign=traffic%20boost&utm_content=extended%20%traffic%boost"
        let linkRange: Range<Int> = 0..<link.endIndex.encodedOffset
        
        let expect = ComplexLinkExpect(link, [LinkExpect(url.absoluteString, at: linkRange)])
        try! self.detector.process(text: expect.text)
        let result = expect.fullFilExpects()
        XCTAssertTrue(result.success, "FAIL: \(result.description)")
    }
    
    func testInlineQuoteWrappedLink() {
        
        let string = "- DASHBOARD_CONFIGURE_ENDPOINT=\"http://configer:8081/1\""
        
        let linkRange = (string as NSString).range(of: "http://configer:8081")
        let expectedRange: Range<Int> = linkRange.location..<NSMaxRange(linkRange)
        
        let expect = ComplexLinkExpect(string, [LinkExpect("http://configer:8081", at: expectedRange)])
        try! self.detector.process(text: expect.text)
        let result = expect.fullFilExpects()
        XCTAssertTrue(result.success, "FAIL: \(result.description)")
    }
    
    func testComplexCases() {
        let expects: [ComplexLinkExpect] = [
            ComplexLinkExpect("(https://tjournal.ru/45989-chto-nuzhno-znat-o-novom-zakone-o-personalnih-dannih и https://www.consultant.ru/document/cons_doc_LAW_212391/3d0cac60971a511280cbba229d9b6329c07731f7)",
                              [
                                LinkExpect("https://tjournal.ru/45989-chto-nuzhno-znat-o-novom-zakone-o-personalnih-dannih", at: 1..<79),
                                LinkExpect("https://www.consultant.ru/document/cons_doc_LAW_212391/3d0cac60971a511280cbba229d9b6329c07731f7", at: 81..<174)
                ])
        ]
        for expect in expects {
            try! self.detector.process(text: expect.text)
            let result = expect.fullFilExpects()
            if !result.success {
                XCTFail("FAIL: \(result.description)")
            }
        }
    }
    
    func testMultilineClosureEndedUrl() {
        let string = "123456789\nO, hi there! http://google.com/) – tap it!\n456456"
        let unprepraredRange = string.range(of: "http://google.com/)")!
        let range: Range<Int> = unprepraredRange.lowerBound.encodedOffset..<unprepraredRange.upperBound.encodedOffset
        let expect = ComplexLinkExpect(string, [LinkExpect("http://google.com/)", at: range)])
        try! self.detector.process(text: expect.text)
        let result = expect.fullFilExpects()
        if !result.success {
            XCTFail("FAIL: \(result.description)")
        }
    }
    
    func testMultilineUrl() {
        let string = "123456789\nO, hi there! http://google.com/ – tap it!\n456456"
        let unprepraredRange = string.range(of: "http://google.com/")!
        let range: Range<Int> = unprepraredRange.lowerBound.encodedOffset..<unprepraredRange.upperBound.encodedOffset
        let expect = ComplexLinkExpect(string, [LinkExpect("http://google.com/", at: range)])
        try! self.detector.process(text: expect.text)
        let result = expect.fullFilExpects()
        if !result.success {
            XCTFail("FAIL: \(result.description)")
        }
    }
    
    func testDefaultCases() {
        
        let expects: [ComplexLinkExpect] = [
            ComplexLinkExpect("http://dialog.chat/ - test this", [LinkExpect("http://dialog.chat/", at: 0..<19)]),
            ComplexLinkExpect("test: https://dlg.im)", [LinkExpect("https://dlg.im", at: 6..<20)]),
            ComplexLinkExpect("(https://dlg.im)", [LinkExpect("https://dlg.im", at: 1..<15)]),
            ComplexLinkExpect("https://dlg.im/foo))hello", [LinkExpect("https://dlg.im/foo))hello", at: 0..<25)]),
            ComplexLinkExpect("https://google.com/test?x=123", [LinkExpect("https://google.com/test?x=123", at: 0..<29)]),
            ComplexLinkExpect("https://dlg.im/foo((hello", [LinkExpect("https://dlg.im/foo((hello", at: 0..<25)]),
            ComplexLinkExpect("www.google.com", [LinkExpect("http://www.google.com", at: 0..<14)]),
            ComplexLinkExpect("yandex.ru/news", [LinkExpect("http://yandex.ru/news", at: 0..<14)]),
            ComplexLinkExpect("http://www.🍕💩.ws/💩💩💩",
                              [LinkExpect("http://www.xn--vi8hiv.ws/%F0%9F%92%A9%F0%9F%92%A9%F0%9F%92%A9", at: 0..<20)]),
            ComplexLinkExpect("http://xn--h1aax.xn--p1ai/smi/18390/",
                              [LinkExpect("http://xn--h1aax.xn--p1ai/smi/18390/", at: 0..<35)]),
            ComplexLinkExpect("http://amazinghiring.com/blog/2017/08/30/в-skype-появился-встроенный-редактор-кода/",
                              [LinkExpect("http://amazinghiring.com/blog/2017/08/30/%D0%B2-skype-%D0%BF%D0%BE%D1%8F%D0%B2%D0%B8%D0%BB%D1%81%D1%8F-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%BE%D1%80-%D0%BA%D0%BE%D0%B4%D0%B0/", at: 0..<83)]),
            ComplexLinkExpect("http://кто.рф?foo=Привет,Мир!",
                              [LinkExpect("http://xn--j1ail.xn--p1ai/?foo=%D0%9F%D1%80%D0%B8%D0%B2%D0%B5%D1%82,%D0%9C%D0%B8%D1%80!", at: 0..<29)])
        ]
        for expect in expects {
            try! self.detector.process(text: expect.text)
            let result = expect.fullFilExpects()
            if !result.success {
                XCTFail("FAIL: \(result.description)")
            }
        }
    }
    
    /// This function used when there is need to test one special case from default cases for fixing the problem.
    /// When you found a new problem with default case you can place it here to debug and fix.
    /// After fixing remove ot comment expect from array. Test with no expects will succesfully finished.
    func testCurrentlyFixingCase() {
        let expects = [
            ComplexLinkExpect("http://www.🍕💩.ws/💩💩💩",
                              [LinkExpect("http://www.xn--vi8hiv.ws/%F0%9F%92%A9%F0%9F%92%A9%F0%9F%92%A9", at: 0..<20)])
        ]
        for expect in expects {
            try! self.detector.process(text: expect.text)
            let result = expect.fullFilExpects()
            if !result.success {
                XCTFail("FAIL: \(result.description)")
            }
        }
    }
    
    func testSimpleCaseWithTextAfterUrl() {
        let text = createText("http://dialog.chat/ - test this")
        let link = "http://dialog.chat/"
        let expect = LinkExpect.init(link: link, range: (text.string as NSString).range(of: link))
        try! detector.process(text: text)
        self.enumerateAttribute(.url, in: text) { (value, range) in
            guard let v = value else {
                return
            }
            guard let url = v as? URL else {
                XCTFail("Unexpected detector result: \(String(describing: value))")
                return
            }
            
            expect.verify(url: url, range: range)
            XCTAssertTrue(expect.isVerified, "Fail \(text.string):\n \(expect.description)")
        }
    }
    
    func createExpects(link: String) -> [String : LinkExpect] {
        
        let wrappedLinks: [String] = [
            link,
            " \(link)",
            "\(link) ",
            " \(link) ",
            "sdfsdf \(link)",
            "[\(link)]",
            ",\(link)",
            "\(link),"
        ]
        
        var expects: [String : LinkExpect] = [:]
        for item in wrappedLinks {
            expects[item] = LinkExpect.init(link: link, range: (item as NSString).range(of: link))
        }
        return expects
    }
    
    func testBasicMarkdownLink() {
        let text = NSMutableAttributedString.init(string: "[Dialog](https://dlg.im)")
        
        try! detector.process(text: text)
        
        var checked = Checked()
        
        let expected = Expected.init(string: text.string, text: "Dialog", link: "https://dlg.im")
        
        text.enumerateDetectorAttribute(.markdownUrl, block: { value, range, _ in
            guard let url = value as? UrlDetector.MarkdownUrl else {
                XCTFail("Unexpected attribute value: \(String(describing: value))")
                return
            }
            
            XCTAssertEqual(url.text, expected.text)
            checked.text = true
            
            XCTAssertEqual(url.link, expected.link)
            checked.link = true
            
            XCTAssertTrue(NSEqualRanges(range, expected.fullRange))
            XCTAssertFalse(checked.full)
            
            checked.full = true
            
        })
        
        XCTAssertTrue(checked.full && checked.link && checked.text, "Some of items were not found")
    }
    
    func testInTextMarkdownLinks() {
        let text = NSMutableAttributedString(string: "Log text that [links](http://google.com) to some url as well as another [a link](ssh://yandex.ru).")
        let detector = UrlDetector.init()
        try! detector.process(text: text)
        
        let attr = DetectorAttributeName.markdownUrl.rawValue
        let range = NSRange(location: 0, length: text.string.characters.count)
        
        let expected: [Expected] = [
            Expected.init(string: "[links](http://google.com)",
                          fullRangeIn: text.string,
                          text: "links",
                          link: "http://google.com"),
            
            Expected.init(string: "[a link](ssh://yandex.ru)",
                          fullRangeIn: text.string,
                          text: "a link",
                          link: "ssh://yandex.ru")
        ]
        
        text.enumerateAttribute(attr, in: range, options: [], using: { value, range, _ in
            
            guard let v = value else {
                return
            }
            
            guard let url = v as? UrlDetector.MarkdownUrl else {
                XCTFail("Unexpected attribute value: \(String(describing: value))")
                return
            }
            guard let expectedItem = expected.first(where: { NSEqualRanges($0.fullRange, range) }) else {
                XCTFail("Unexpected item at range: \(range)")
                return
            }
            XCTAssertEqual(url.text, expectedItem.text)
            XCTAssertEqual(url.link, expectedItem.link)
            
        })
        
    }
    
}
