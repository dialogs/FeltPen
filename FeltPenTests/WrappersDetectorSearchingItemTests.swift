
//
//  WrappersDetectorSearchingItemTests.swift
//  FeltPen
//
//  Created by Aleksei Gordeev on 08/07/2017.
//  Copyright Â© 2017 CocoaPods. All rights reserved.
//

import XCTest
@testable import FeltPen


fileprivate extension NSRange {
    
    static func makeRange(_ location: Int, _ length: Int) -> NSRange {
        return NSRange(location: location, length: length)
    }
    
    var descr: String {
        return NSStringFromRange(self)
    }
    
}

fileprivate extension Array where Element == NSRange {
    
    var rangeDescriptions: [String] {
        return self.map({$0.descr})
    }
    
    var rangesDescription: String {
        return "\(rangeDescriptions)"
    }
    
}


class WrappersDetectorSearchingItemTests: XCTestCase {
    
    struct TestTask {
        
        var string: String
        
        /// Sorted by locations
        var expectedRanges: [NSRange]
        
        var wholeRange: NSRange {
            return .makeRange(0, string.characters.count)
        }
        
        init(_ string: String, _ expectedRanges: [NSRange]? = nil) {
            self.string = string
            self.expectedRanges = expectedRanges ?? [NSRange(location: 0, length: string.characters.count)]
        }
    }
    
    func testBacktickPattern() {
        let pattern = WrappersDetector.createRegex(item: .backtick).pattern
        XCTAssertEqual(pattern, "(?:^|[ .,#!$%^&;:{}=_~()\\/-/*])(`[^`]+`)(?:$|[ .,#!$%^&;:{}=_~()\\/-/*])")
    }
    
    func testBasicSimpleFalseNegativeCases() {
        
        let testCasesByItems: [WrappersDetector.SearchingItem : [TestTask]] = [
            WrappersDetector.SearchingItem.backtick : [
                TestTask.init("`test`"),
                TestTask.init("`test test`"),
                TestTask.init("`test` not-in", [.makeRange(0, 6)]),
                TestTask.init(" `test` not from start", [.makeRange(1, 6)]),
                TestTask.init(" `test` `test`", [.makeRange(1, 6), .makeRange(8, 6)])
            ],
            
            WrappersDetector.SearchingItem.asteriks : [
                TestTask.init("*test*"),
                TestTask.init("*test test*"),
                TestTask.init("*test* partial", [.makeRange(0, 6)]),
                TestTask.init(" *test* not from start", [.makeRange(1, 6)])
            ],
            
            WrappersDetector.SearchingItem.underscore : [
                TestTask.init("_test_"),
                TestTask.init("_test test_"),
                TestTask.init("_test_ partial", [.makeRange(0, 6)]),
                TestTask.init(" _test_ not from start", [.makeRange(1, 6)])
            ],
            
            WrappersDetector.SearchingItem.tilde : [
                TestTask.init("~test~"),
                TestTask.init("~test test~"),
                TestTask.init("~test~ partial", [.makeRange(0, 6)]),
                TestTask.init(" ~test~ not from start", [.makeRange(1, 6)])
            ]
        ]
        
        testCasesByItems.forEach({ (item, tasks) in
            
            let detector = WrappersDetector.init(searchingItems: [item])
            
            for task in tasks {
                
                let text = NSMutableAttributedString.init(string: task.string)
                try! detector.process(text: text)
                
                let attr = item.detectorAttributeName.rawValue
                
                var expectedRanges = task.expectedRanges
                text.enumerateAttribute(attr, in: task.wholeRange, options: [], using: { value, range, stop in
                    guard let nonnullValue = value else {
                        return
                    }
                    
                    guard let value = nonnullValue as? WrappersDetector.SpotAttribute else {
                        XCTFail("Unexpected attribute type")
                        return
                    }
                    
                    XCTAssertEqual(value.item, item)
                    
                    guard let idx = expectedRanges.index(where: { NSEqualRanges($0, range)}) else {
                        let foundSubstring = (text.string as NSString).substring(with: range)
                        XCTFail("Could not found \(range.descr) (\(foundSubstring)) in \(expectedRanges.map({$0.descr}))")
                        return
                    }
                    
                    expectedRanges.remove(at: idx)
                })
            }
        })
    }
    
    func testWrappedInOtherItemsFalseNegativeCases() {
        
        let testCasesByItems: [WrappersDetector.SearchingItem : [TestTask]] = [
            WrappersDetector.SearchingItem.backtick : [
                TestTask.init("_`test`_", [.makeRange(1, 6)]),
                TestTask.init("_`test test`_", [.makeRange(1, 11)]),
                TestTask.init("_`test`_ not-in", [.makeRange(1, 6)]),
                TestTask.init(" _`test`_ not from start", [.makeRange(2, 6)]),
                TestTask.init(" _`test`_ _`test`_", [.makeRange(2, 6), .makeRange(11, 6)])
            ]
        ]
        
        testCasesByItems.forEach({ (item, tasks) in
            
            let detector = WrappersDetector.init(searchingItems: [item])
            
            for task in tasks {
                
                let text = NSMutableAttributedString.init(string: task.string)
                try! detector.process(text: text)
                
                let attr = item.detectorAttributeName.rawValue
                
                var expectedRanges = task.expectedRanges
                text.enumerateAttribute(attr, in: task.wholeRange, options: [], using: { value, range, stop in
                    guard let nonnullValue = value else {
                        return
                    }
                    
                    guard let value = nonnullValue as? WrappersDetector.SpotAttribute else {
                        XCTFail("Unexpected attribute type")
                        return
                    }
                    
                    XCTAssertEqual(value.item, item)
                    
                    guard let idx = expectedRanges.index(where: { NSEqualRanges($0, range)}) else {
                        XCTFail("Could not found \(range.descr) in \(expectedRanges.map({$0.descr}))")
                        return
                    }
                    
                    expectedRanges.remove(at: idx)
                })
            }
        })
    }
    
}
